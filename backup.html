<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Car Driving Game</title>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, Helvetica, sans-serif;
        }
        canvas { display: block; }
        .controls { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            max-width: 160px;
        }
        .vehicle-select {
            margin-bottom: 10px;
            width: 100%;
            padding: 8px;
            font-size: 16px;
            border-radius: 4px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .stat-bar {
            margin-top: 5px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }
        .stat-fill {
            height: 100%;
            background: #4CAF50;
        }
        .description {
            margin-top: 12px;
            font-size: 14px;
            font-family: Arial, Helvetica, sans-serif;
        }
        /* New styles for multiplayer */
        .player-name {
            position: absolute;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 14px;
            transform: translateX(-50%);
            pointer-events: none;
        }
        .multiplayer-info {
            margin-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.3);
            padding-top: 10px;
        }
        .controls-info {
            margin-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.3);
            padding-top: 10px;
            font-size: 14px;
            color: white;
        }
        .controls-key {
            display: inline-block;
            background: rgba(255,255,255,0.3);
            color: #fff;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 3px 0;
        }
        .player-list {
            max-height: 100px;
            overflow-y: auto;
            margin-top: 5px;
        }
        .player-item {
            padding: 3px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        /* Connection UI */
        #connection-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        /* Collision effect */
        #collision-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.2);
            pointer-events: none;
            z-index: 900;
            display: none;
            animation: flash 0.5s;
        }
        @keyframes flash {
            0% { opacity: 0; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }
        .connection-box {
            background: #222;
            padding: 30px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
        }
        .connection-box h2 {
            margin-top: 0;
            color: white;
        }
        .connection-box input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border: none;
            font-size: 16px;
        }
        .connection-box button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-top: 10px;
            margin-bottom: 20px;
        }
        .connection-box .controls-info {
            margin-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.3);
            padding-top: 15px;
            color: white;
            font-size: 14px;
        }
        .connection-box .controls-info h3 {
            margin-top: 0;
            color: white;
        }
        .connection-box .controls-info p {
            color: white;
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <!-- Connection Screen -->
    <div id="connection-screen">
        <div class="connection-box">
            <h2>Join Multiplayer Game</h2>
            <input type="text" id="player-name" placeholder="Enter your name" value="Player">
            <button id="join-button">Join Game</button>
            
            <!-- Controls info moved to connection screen -->
            <div class="controls-info">
                <h3>Controls</h3>
                <p>Use the following keys to control your vehicle:</p>
                <p><span class="controls-key">Up Arrow</span> or <span class="controls-key">W</span> - Accelerate</p>
                <p><span class="controls-key">Down Arrow</span> or <span class="controls-key">S</span> - Brake</p>
                <p><span class="controls-key">Left Arrow</span> or <span class="controls-key">A</span> - Turn Left</p>
                <p><span class="controls-key">Right Arrow</span> or <span class="controls-key">D</span> - Turn Right</p>
                <p><span class="controls-key">Space</span> - Toggle Headlights</p>
                <p><span class="controls-key">H</span> - Sound Car Horn</p>
            </div>
        </div>
    </div>

    <!-- Collision effect overlay -->
    <div id="collision-effect"></div>

    <div class="controls">
        <h3>Select Vehicle</h3>
        <select id="vehicle-select" class="vehicle-select">
            <option value="">Loading vehicles...</option>
        </select>
        <div class="stats">
            <div>
                <div>Speed:</div>
                <div class="stat-bar"><div id="speed-bar" class="stat-fill" style="width: 0%"></div></div>
            </div>
            <div>
                <div>Handling:</div>
                <div class="stat-bar"><div id="handling-bar" class="stat-fill" style="width: 0%"></div></div>
            </div>
            <div>
                <div>Acceleration:</div>
                <div class="stat-bar"><div id="acceleration-bar" class="stat-fill" style="width: 0%"></div></div>
            </div>
            <div>
                <div>Shield:</div>
                <div class="stat-bar"><div id="shield-bar" class="stat-fill" style="width: 0%"></div></div>
            </div>
        </div>
        <div id="description" class="description"></div>

        <!-- Multiplayer info section -->
        <div class="multiplayer-info">
            <h3>Connected Players (<span id="player-count">0</span>)</h3>
            <div id="player-list" class="player-list"></div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Store vehicle data
        let vehiclesData = [];
        let currentVehicleData = null;

        // Multiplayer variables
        let socket;
        let playerName = "Player";
        let playerID;
        let otherPlayers = {}; // Store other players' cars
        let otherPlayersData = {}; // Store other players' data
        let nameLabels = {}; // Store name labels for players
        let otherPlayersHeadlights = {}; // Store headlights for other players
        let headlightsOn = true; // Headlight state
        let controlsDisabled = false; // For collision response
        let controlsDisabledTimeout = null; // For tracking control recovery

        // Audio context and sounds
        let audioContext;
        let hornSound;

        // Initialize Audio
        function initAudio() {
            // Create audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Load horn sound
            fetch('/soundfx/horn.mp3')
                .then(response => response.arrayBuffer())
                .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                .then(audioBuffer => {
                    hornSound = audioBuffer;
                })
                .catch(error => console.error('Error loading horn sound:', error));
        }

        // Play horn sound
        function playHorn() {
            if (audioContext && hornSound) {
                const source = audioContext.createBufferSource();
                source.buffer = hornSound;
                source.connect(audioContext.destination);
                source.start(0);
                
                // Notify other players
                if (socket && socket.connected) {
                    socket.emit('hornSound', {});
                }
            }
        }

        // Connection handling
        document.getElementById('join-button').addEventListener('click', connectToServer);
        document.getElementById('player-name').addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                connectToServer();
            }
        });

        function connectToServer() {
            playerName = document.getElementById('player-name').value || "Player";
            document.getElementById('connection-screen').style.display = 'none';
            
            // Initialize Socket.io connection
            socket = io();
            
            // Socket connection event handlers
            socket.on('connect', function() {
                playerID = socket.id;
                console.log('Connected to server with ID:', playerID);
                
                // Join the game after the first vehicle is loaded
                if (vehiclesData.length > 0) {
                    joinGame();
                }
            });
            
            // When we receive the current players list
            socket.on('currentPlayers', function(players) {
                Object.keys(players).forEach(function(id) {
                    // Add all players except ourself
                    if (id !== playerID) {
                        addOtherPlayer(players[id]);
                    }
                });
                updatePlayerList();
            });
            
            // When a new player joins
            socket.on('newPlayer', function(playerInfo) {
                addOtherPlayer(playerInfo);
                updatePlayerList();
            });
            
            // When a player moves
            socket.on('playerMoved', function(moveData) {
                if (otherPlayers[moveData.id]) {
                    // Smoothly move the player
                    const player = otherPlayers[moveData.id];
                    
                    // Create target position and rotation
                    const targetPos = new THREE.Vector3(
                        moveData.position.x,
                        moveData.position.y,
                        moveData.position.z
                    );
                    
                    // Store target values for interpolation in animation loop
                    player.targetPosition = targetPos;
                    player.targetRotation = { y: moveData.rotation.y };
                    
                    // Update the name label position
                    updateNameLabel(moveData.id);
                }
            });
            
            // When a player changes vehicle
            socket.on('playerVehicleChanged', function(changeData) {
                if (otherPlayers[changeData.id]) {
                    // Remove the old vehicle
                    scene.remove(otherPlayers[changeData.id]);
                    
                    // Clean up headlights (important to prevent memory leaks)
                    if (otherPlayersHeadlights[changeData.id]) {
                        delete otherPlayersHeadlights[changeData.id];
                    }
                    
                    // Load the new vehicle
                    const playerData = otherPlayersData[changeData.id];
                    playerData.vehicleId = changeData.vehicleId;
                    
                    loadOtherPlayerCar(changeData.id, playerData);
                    updatePlayerList();
                }
            });
            
            // When a player toggles headlights
            socket.on('headlightsToggled', function(data) {
                if (otherPlayers[data.id] && otherPlayersHeadlights[data.id]) {
                    // Toggle the visibility of the other player's headlights
                    otherPlayersHeadlights[data.id].forEach(light => {
                        light.visible = data.headlightsOn;
                    });
                }
            });
            
            // When a player honks their horn
            socket.on('playerHornSound', function(data) {
                if (otherPlayers[data.id]) {
                    // Play horn sound for another player
                    playHorn();
                }
            });
            
            // When another player collides with you
            socket.on('playerCollidedWithYou', function(data) {
                if (currentCar && otherPlayers[data.id]) {
                    // Get the other player's position
                    const otherPos = new THREE.Vector3(
                        data.position.x,
                        data.position.y,
                        data.position.z
                    );
                    
                    // Calculate collision response direction (pushes away from other car)
                    const pushDirection = new THREE.Vector3().subVectors(currentCar.position, otherPos).normalize();
                    
                    // Apply "bounce" force to our car
                    currentCar.position.add(pushDirection.multiplyScalar(collisionBounceStrength));
                    
                    // Temporarily disable controls
                    disableControls();
                    
                    // Play collision sound
                    playCollisionSound();
                    
                    // Show visual collision effect - only for the player who was hit
                    showCollisionEffect();
                    
                    // Update server with our new position
                    emitPlayerMovement();
                }
            });
            
            // When two other players collide (for visual and sound effects)
            socket.on('playersCollided', function(data) {
                // We're not involved in this collision, just witnessing it
                // Could add visual effects here if desired
                if (otherPlayers[data.player1] && otherPlayers[data.player2]) {
                    // Play a distant collision sound at lower volume
                    playDistantCollisionSound();
                }
            });
            
            // When a player leaves
            socket.on('playerLeft', function(id) {
                if (otherPlayers[id]) {
                    // Remove their car
                    scene.remove(otherPlayers[id]);
                    delete otherPlayers[id];
                    
                    // Clean up headlights
                    if (otherPlayersHeadlights[id]) {
                        delete otherPlayersHeadlights[id];
                    }
                    
                    // Remove their data
                    delete otherPlayersData[id];
                    
                    // Remove their name label
                    if (nameLabels[id]) {
                        document.body.removeChild(nameLabels[id]);
                        delete nameLabels[id];
                    }
                    
                    updatePlayerList();
                }
            });
            
            socket.on('disconnect', function() {
                console.log('Disconnected from server');
                
                // Clear other players
                Object.keys(otherPlayers).forEach(id => {
                    scene.remove(otherPlayers[id]);
                    
                    // Clean up headlights
                    if (otherPlayersHeadlights[id]) {
                        delete otherPlayersHeadlights[id];
                    }
                    
                    if (nameLabels[id]) {
                        document.body.removeChild(nameLabels[id]);
                    }
                });
                
                otherPlayers = {};
                otherPlayersData = {};
                nameLabels = {};
                otherPlayersHeadlights = {};
                
                updatePlayerList();
                
                // Show connection screen again so user can reconnect
                document.getElementById('connection-screen').style.display = 'flex';
            });
        }

        function joinGame() {
            // Get the currently selected vehicle
            const selectElement = document.getElementById('vehicle-select');
            const vehicleId = selectElement.value;
            
            // Join as a player with the selected vehicle
            socket.emit('playerJoin', {
                vehicleId: vehicleId,
                position: { x: currentCar.position.x, y: currentCar.position.y, z: currentCar.position.z },
                rotation: { y: currentCar.rotation.y },
                playerName: playerName
            });
        }

        function addOtherPlayer(playerInfo) {
            // Store player data
            otherPlayersData[playerInfo.id] = playerInfo;
            
            // Load their car
            loadOtherPlayerCar(playerInfo.id, playerInfo);
            
            // Create name label
            createNameLabel(playerInfo.id, playerInfo.playerName);
        }

        function loadOtherPlayerCar(playerId, playerInfo) {
            const vehicle = vehiclesData.find(v => v.id === playerInfo.vehicleId);
            
            if (!vehicle) {
                console.error('Could not find vehicle:', playerInfo.vehicleId);
                return;
            }
            
            loader.load(
                'models/' + vehicle.file,
                (gltf) => {
                    const car = gltf.scene;
                    
                    // Position at player's location
                    car.position.set(
                        playerInfo.position.x,
                        playerInfo.position.y,
                        playerInfo.position.z
                    );
                    
                    car.rotation.y = playerInfo.rotation.y;
                    
                    // Store reference to this player's car
                    otherPlayers[playerId] = car;
                    
                    // Add the car to the scene
                    scene.add(car);
                    
                    // Add headlights to other player's car (with player ID)
                    addHeadlightsToOtherPlayer(car, playerId);
                    
                    // Update the name label
                    updateNameLabel(playerId);
                    
                    console.log(`Loaded other player ${playerInfo.playerName} at position:`, 
                        playerInfo.position.x.toFixed(2), 
                        playerInfo.position.y.toFixed(2), 
                        playerInfo.position.z.toFixed(2),
                        'Rotation:', playerInfo.rotation.y.toFixed(2));
                },
                undefined,
                (error) => {
                    console.error('Error loading other player model:', error);
                }
            );
        }

        // Function to add headlights to other players' cars
        function addHeadlightsToOtherPlayer(car, playerId) {
            // Create array to store this player's headlights
            otherPlayersHeadlights[playerId] = [];
            
            // Get player data
            const playerData = otherPlayersData[playerId];
            const initialHeadlightState = playerData.headlightsOn !== undefined ? playerData.headlightsOn : true;
            
            // Create headlight parameters - similar to the player's headlights but less intense
            const headlightColor = 0xffffcc; // Warm white color
            const headlightIntensity = 4; // Reduced intensity for other players
            const headlightDistance = 50; // Reduced distance for other players
            const headlightAngle = Math.PI / 6;
            const headlightPenumbra = 0.3;
            const headlightDecay = 1.5;
            
            // Adjustable headlight position parameters
            const headlightOffsetX = 0.275;  // Distance from center (left/right)
            const headlightOffsetY = 0.39;   // Height from car
            const headlightOffsetZ = 1.2;    // Forward position from car center
            const headlightTargetZ = 50;     // How far forward the light points
            
            // Create left headlight
            const leftHeadlight = new THREE.SpotLight(
                headlightColor, 
                headlightIntensity,
                headlightDistance,
                headlightAngle,
                headlightPenumbra,
                headlightDecay
            );
            
            // Position left headlight relative to car
            leftHeadlight.position.set(headlightOffsetX, headlightOffsetY, headlightOffsetZ);
            leftHeadlight.castShadow = false; // Disable shadow casting for performance
            car.add(leftHeadlight);
            leftHeadlight.target.position.set(0, 0, headlightTargetZ); // Point forward
            car.add(leftHeadlight.target);
            
            // Create right headlight
            const rightHeadlight = new THREE.SpotLight(
                headlightColor, 
                headlightIntensity,
                headlightDistance,
                headlightAngle,
                headlightPenumbra,
                headlightDecay
            );
            
            // Position right headlight relative to car
            rightHeadlight.position.set(-headlightOffsetX, headlightOffsetY, headlightOffsetZ);
            rightHeadlight.castShadow = false; // Disable shadow casting for performance
            car.add(rightHeadlight);
            rightHeadlight.target.position.set(0, 0, headlightTargetZ); // Point forward
            car.add(rightHeadlight.target);
            
            // Store headlights for cleanup later
            otherPlayersHeadlights[playerId].push(leftHeadlight, rightHeadlight);
            
            // Add visible headlight objects
            const headlightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const headlightMaterial = new THREE.MeshBasicMaterial({ 
                color: headlightColor, 
                emissive: headlightColor,
                emissiveIntensity: 2
            });
            
            const leftHeadlightMesh = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlightMesh.position.copy(leftHeadlight.position);
            car.add(leftHeadlightMesh);
            
            const rightHeadlightMesh = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlightMesh.position.copy(rightHeadlight.position);
            car.add(rightHeadlightMesh);
            
            // Set initial visibility based on player's headlight state
            leftHeadlight.visible = initialHeadlightState;
            rightHeadlight.visible = initialHeadlightState;
        }

        function createNameLabel(playerId, name) {
            const label = document.createElement('div');
            label.className = 'player-name';
            label.textContent = name;
            document.body.appendChild(label);
            
            nameLabels[playerId] = label;
            
            // Position the label
            updateNameLabel(playerId);
        }

        function updateNameLabel(playerId) {
            if (!nameLabels[playerId] || !otherPlayers[playerId]) return;
            
            // Get screen position for the player's car
            const position = new THREE.Vector3();
            position.setFromMatrixPosition(otherPlayers[playerId].matrixWorld);
            position.y += 1.5; // Position above the car
            
            // Convert 3D position to screen coordinates
            const screenPosition = position.clone();
            screenPosition.project(camera);
            
            // Convert to CSS coordinates
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;
            
            // Update label position
            nameLabels[playerId].style.left = x + 'px';
            nameLabels[playerId].style.top = y + 'px';
            
            // Only show if in front of camera
            if (screenPosition.z > 1) {
                nameLabels[playerId].style.display = 'none';
            } else {
                nameLabels[playerId].style.display = 'block';
            }
        }

        function updatePlayerList() {
            const playerListElement = document.getElementById('player-list');
            const playerCount = document.getElementById('player-count');
            
            // Clear current list
            playerListElement.innerHTML = '';
            
            // Add self
            const selfItem = document.createElement('div');
            selfItem.className = 'player-item';
            selfItem.textContent = playerName + ' (You)';
            playerListElement.appendChild(selfItem);
            
            // Add other players
            Object.keys(otherPlayersData).forEach(id => {
                const playerData = otherPlayersData[id];
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.textContent = playerData.playerName;
                playerListElement.appendChild(playerItem);
            });
            
            // Update count
            const count = 1 + Object.keys(otherPlayersData).length;
            playerCount.textContent = count;
        }

        // Load vehicles data
        fetch('vehicles.json')
            .then(response => response.json())
            .then(data => {
                vehiclesData = data.vehicles;
                const selectElement = document.getElementById('vehicle-select');
                
                // Clear loading option
                selectElement.innerHTML = '';
                
                // Add options for each vehicle
                vehiclesData.forEach(vehicle => {
                    const option = document.createElement('option');
                    option.value = vehicle.id;
                    option.textContent = vehicle.name;
                    selectElement.appendChild(option);
                });
                
                // Load the first vehicle by default
                if (vehiclesData.length > 0) {
                    selectElement.value = vehiclesData[0].id;
                    updateVehicleStats(vehiclesData[0]);
                    loadCar(vehiclesData[0].file);
                }
                
                // Join game if socket is already connected
                if (socket && socket.connected) {
                    joinGame();
                }
            })
            .catch(error => console.error('Error loading vehicles data:', error));

        // Initialize Scene, Camera, and Renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.2, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
        document.body.appendChild(renderer.domElement);
        
        // Set background color darker for better light contrast
        scene.background = new THREE.Color(0x222222);

        // Create Ground (Open Field)
        const groundGeometry = new THREE.PlaneGeometry(300, 300);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a6e2a, // Darker green for grass
            roughness: 0.8,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Make it horizontal
        ground.receiveShadow = true; // Allow ground to receive shadows
        scene.add(ground);

        // Create a flat race track with 7 turns
        function createFlatRaceTrack() {
            // Track points for a race track with 7 turns
            const trackPath = [
                [-25, -25], // Start point
                [25, -25],  // Straight section
                [30, -15],  // Turn 1
                [15, -5],   // Turn 2
                [20, 15],   // Turn 3
                [0, 25],    // Turn 4
                [-20, 15],  // Turn 5
                [-30, -5],  // Turn 6
                [-25, -25]  // Turn 7 and back to start
            ];
            
            // Create smooth curve from control points
            const curvePoints = [];
            trackPath.forEach(point => {
                curvePoints.push(new THREE.Vector3(point[0], 0, point[1]));
            });
            
            // Create a closed curve that passes through all points
            const curve = new THREE.CatmullRomCurve3(curvePoints);
            curve.closed = true;
            
            // Track properties
            const trackWidth = 10;
            const trackColor = 0x212121; // Dark gray
            
            // Create vertices for a flat ribbon following the curve
            const numPoints = 200;
            const points = curve.getPoints(numPoints);
            const trackGeometry = new THREE.BufferGeometry();
            
            // Create vertices for both sides of the track
            const vertices = [];
            const normals = [];
            const indices = [];
            const uvs = []; // Add UVs for better material rendering
            
            // For each point along the curve
            for (let i = 0; i <= numPoints; i++) {
                const index = i % numPoints; // For closed loop
                const nextIndex = (i + 1) % numPoints;
                
                const currentPoint = points[index];
                const nextPoint = points[nextIndex];
                
                // Calculate the direction vector
                const direction = new THREE.Vector3();
                direction.subVectors(nextPoint, currentPoint).normalize();
                
                // Calculate the perpendicular vector on the horizontal plane
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
                
                // Create left and right vertices for the track
                const leftPoint = new THREE.Vector3().copy(currentPoint).addScaledVector(perpendicular, trackWidth/2);
                const rightPoint = new THREE.Vector3().copy(currentPoint).addScaledVector(perpendicular, -trackWidth/2);
                
                // Add vertices - keeping them flat by maintaining the same y value
                vertices.push(leftPoint.x, 0.01, leftPoint.z);  // Left side of track
                vertices.push(rightPoint.x, 0.01, rightPoint.z); // Right side of track
                
                // Add normals (pointing up)
                normals.push(0, 1, 0, 0, 1, 0);
                
                // Add UVs for texturing - map U along track length and V across width
                const uCoord = i / numPoints;
                uvs.push(uCoord, 0);
                uvs.push(uCoord, 1);
                
                // Create triangles (two per track segment)
                if (i < numPoints) {
                    const vertIndex = i * 2;
                    indices.push(vertIndex, vertIndex + 1, vertIndex + 2); // First triangle
                    indices.push(vertIndex + 1, vertIndex + 3, vertIndex + 2); // Second triangle
                }
            }
            
            // Set geometry attributes
            trackGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            trackGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            trackGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2)); // Add UVs
            trackGeometry.setIndex(indices);
            trackGeometry.computeBoundingSphere();
            
            // Create track material that responds to light like the ground
            const trackMaterial = new THREE.MeshStandardMaterial({
                color: trackColor,
                roughness: 2,           // Match ground roughness
                metalness: 0.1,           // Match ground metalness
                emissive: 0x000000,       // No self-illumination
                side: THREE.DoubleSide,
                flatShading: false        // Use smooth shading instead of flat shading
            });
            
            // Create the track mesh - flat on the ground
            const track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.receiveShadow = true;   // Allow track to receive shadows
            
            // Ensure the track is slightly above the ground to prevent z-fighting
            track.position.y = 0.02;
            
            scene.add(track);
            
            // For visualization of the curve (optional)
            // const curveGeometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(200));
            // const curveMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            // const curveObject = new THREE.Line(curveGeometry, curveMaterial);
            // scene.add(curveObject);
            
            return {
                startPoint: new THREE.Vector3(trackPath[0][0], 0.1, trackPath[0][1])
            };
        }
        
        // Create the track
        const raceTrack = createFlatRaceTrack();

        // Function to generate a random spawn point
        function getRandomSpawnPoint() {
            // Define bounds for spawning (keep within the track area)
            const spawnBounds = {
                minX: -30,
                maxX: 30,
                minZ: -30,
                maxZ: 30
            };
            
            const minDistanceFromOthers = 5; // Minimum distance from other players
            let isValidSpawn = false;
            let attempts = 0;
            let randomX, randomZ, randomRotation;
            
            // Try up to 10 times to find a valid spawn point
            while (!isValidSpawn && attempts < 10) {
                attempts++;
                
                // Generate random position within bounds
                randomX = spawnBounds.minX + Math.random() * (spawnBounds.maxX - spawnBounds.minX);
                randomZ = spawnBounds.minZ + Math.random() * (spawnBounds.maxZ - spawnBounds.minZ);
                
                // Random rotation (facing any direction)
                randomRotation = Math.random() * Math.PI * 2;
                
                // Check distance from other players
                isValidSpawn = true; // Assume valid until proven otherwise
                
                // If there are other players, check distances
                if (Object.keys(otherPlayers).length > 0) {
                    for (const id in otherPlayers) {
                        const otherPlayer = otherPlayers[id];
                        const distance = Math.sqrt(
                            Math.pow(randomX - otherPlayer.position.x, 2) + 
                            Math.pow(randomZ - otherPlayer.position.z, 2)
                        );
                        
                        if (distance < minDistanceFromOthers) {
                            isValidSpawn = false;
                            break;
                        }
                    }
                }
            }
            
            return {
                position: new THREE.Vector3(randomX, 0.1, randomZ),
                rotation: randomRotation
            };
        }

        // Add Lighting
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.85); // Reduced intensity for better headlight effect
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.5); // Darker ambient for better headlight contrast
        scene.add(ambientLight);

        // Car Management
        let currentCar = null;
        let headlights = []; // Array to store headlight objects
        const loader = new THREE.GLTFLoader();
        
        // Array to store all trees for collision detection
        let trees = [];

        function loadCar(modelFile) {
            // Find the vehicle data
            const vehicle = vehiclesData.find(v => v.file === modelFile);
            if (vehicle) {
                currentVehicleData = vehicle;
                updateVehicleStats(vehicle);
                
                // If socket is connected, notify about vehicle change
                if (socket && socket.connected) {
                    socket.emit('vehicleChange', { vehicleId: vehicle.id });
                }
            }
            
            // Remove previous car and its headlights
            if (currentCar) {
                scene.remove(currentCar);
                headlights.forEach(light => scene.remove(light));
                headlights = [];
            }
            
            // Generate a random spawn point for initial car loading
            const spawnPoint = getRandomSpawnPoint();
            
            loader.load(
                'models/' + modelFile,
                (gltf) => {
                    currentCar = gltf.scene;
                    // Position car at random spawn point instead of track start
                    currentCar.position.copy(spawnPoint.position);
                    currentCar.rotation.y = spawnPoint.rotation;
                    scene.add(currentCar);
                    
                    // Add headlights to the car
                    addHeadlights();
                    
                    // If socket is connected, join game or update position
                    if (socket && socket.connected) {
                        if (!playerID) {
                            joinGame();
                        } else {
                            emitPlayerMovement();
                        }
                    }
                    
                    // After car is loaded, add a tree
                    addRandomTrees();
                },
                undefined,
                (error) => {
                    console.error('Error loading model:', error);
                }
            );
        }
        
        // Function to add multiple random trees away from the track
        function addRandomTrees() {
            console.log('Adding random trees to the scene...');
            
            // Clear existing trees array
            trees = [];
            
            // Tree generation parameters
            const treeCount = 20;                // Number of trees to add
            const minDistanceFromTrack = 8;      // Minimum distance from track center
            const trackWidth = 10;               // Track width from the createFlatRaceTrack function
            const safeDistance = minDistanceFromTrack + trackWidth/2; // Safe distance from track center
            const treePath = 'objects/tree.glb'; // Path to the tree model
            
            // Track points from createFlatRaceTrack function
            const trackPath = [
                [-25, -25], // Start point
                [25, -25],  // Straight section
                [30, -15],  // Turn 1
                [15, -5],   // Turn 2
                [20, 15],   // Turn 3
                [0, 25],    // Turn 4
                [-20, 15],  // Turn 5
                [-30, -5],  // Turn 6
                [-25, -25]  // Turn 7 and back to start
            ];
            
            // Convert track points to Vector3 for distance calculations
            const trackPoints = trackPath.map(point => new THREE.Vector3(point[0], 0, point[1]));
            
            // Function to check if position is too close to track
            function isTooCloseToTrack(position) {
                // Check minimum distance to any track segment
                for (let i = 0; i < trackPoints.length - 1; i++) {
                    const start = trackPoints[i];
                    const end = trackPoints[i + 1];
                    
                    // Create a line from start to end
                    const line = new THREE.Line3(start, end);
                    
                    // Get closest point on line to position
                    const closestPoint = new THREE.Vector3();
                    line.closestPointToPoint(position, true, closestPoint);
                    
                    // Calculate distance to closest point
                    const distance = position.distanceTo(closestPoint);
                    
                    // If too close to any segment, return true
                    if (distance < safeDistance) {
                        return true;
                    }
                }
                return false;
            }
            
            // Generate and place trees
            let treesPlaced = 0;
            let attempts = 0;
            const maxAttempts = 100; // Limit attempts to prevent infinite loop
            
            while (treesPlaced < treeCount && attempts < maxAttempts) {
                attempts++;
                
                // Generate random position within ground boundaries
                const x = Math.random() * 280 - 140; // -140 to 140
                const z = Math.random() * 280 - 140; // -140 to 140
                
                // Create position vector
                const position = new THREE.Vector3(x, 0, z);
                
                // Skip if too close to track
                if (isTooCloseToTrack(position)) {
                    continue;
                }
                
                // Random scale variation
                const scale = 2 + Math.random() * 3; // Scale between 2 and 5
                
                // Load tree model
                loader.load(
                    treePath,
                    (gltf) => {
                        const tree = gltf.scene;
                        
                        // Position the tree
                        tree.position.set(x, 0, z);
                        tree.scale.set(scale, scale, scale);
                        
                        // Random rotation for variety
                        tree.rotation.y = Math.random() * Math.PI * 2;
                        
                        // Add collision data to tree
                        tree.userData.isTree = true;
                        tree.userData.collisionRadius = 1.5 * scale; // Scale-based collision radius
                        
                        // Add to scene
                        scene.add(tree);
                        
                        // Add to trees array for collision detection
                        trees.push({
                            object: tree,
                            position: new THREE.Vector3(x, 0, z),
                            radius: 0.3 * scale // Reduced collision radius for more accuracy
                        });
                        
                        treesPlaced++;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading tree model:', error);
                        
                        // Create fallback tree if model fails to load
                        const geometry = new THREE.ConeGeometry(2, 5, 8);
                        const material = new THREE.MeshStandardMaterial({ color: 0x009900 });
                        const cone = new THREE.Mesh(geometry, material);
                        cone.position.set(x, 2.5, z);
                        cone.castShadow = true;
                        scene.add(cone);
                        
                        // Add fallback tree to trees array
                        trees.push({
                            object: cone,
                            position: new THREE.Vector3(x, 0, z),
                            radius: 1.0 // Reduced fixed collision radius for fallback trees
                        });
                        
                        treesPlaced++;
                    }
                );
            }
            
            console.log(`Placed ${treesPlaced} trees after ${attempts} attempts`);
        }
        
        // Function to add headlights to the car
        function addHeadlights() {
            // Create headlight parameters
            const headlightColor = 0xffffcc; // Warm white color
            const headlightIntensity = 8; // Increased intensity
            const headlightDistance = 100; // Increased distance
            const headlightAngle = Math.PI / 6; // Narrower cone (30 degrees instead of 36)
            const headlightPenumbra = 0.3; // Softer edge
            const headlightDecay = 1.5;
            
            // Adjustable headlight position parameters
            const headlightOffsetX = 0.275;  // Distance from center (left/right)
            const headlightOffsetY = 0.39;  // Height from car
            const headlightOffsetZ = 1.2;    // Forward position from car center
            const headlightTargetZ = 100;   // How far forward the light points
            
            // Create left headlight
            const leftHeadlight = new THREE.SpotLight(
                headlightColor, 
                headlightIntensity,
                headlightDistance,
                headlightAngle,
                headlightPenumbra,
                headlightDecay
            );
            
            // Position left headlight relative to car
            leftHeadlight.position.set(headlightOffsetX, headlightOffsetY, headlightOffsetZ);
            leftHeadlight.castShadow = true; // Enable shadow casting
            currentCar.add(leftHeadlight);
            leftHeadlight.target.position.set(0, 0, headlightTargetZ); // Point forward
            currentCar.add(leftHeadlight.target);
            
            // Create right headlight
            const rightHeadlight = new THREE.SpotLight(
                headlightColor, 
                headlightIntensity,
                headlightDistance,
                headlightAngle,
                headlightPenumbra,
                headlightDecay
            );
            
            // Position right headlight relative to car
            rightHeadlight.position.set(-headlightOffsetX, headlightOffsetY, headlightOffsetZ);
            rightHeadlight.castShadow = true; // Enable shadow casting
            currentCar.add(rightHeadlight);
            rightHeadlight.target.position.set(0, 0, headlightTargetZ); // Point forward
            currentCar.add(rightHeadlight.target);
            
            // Store headlights for later reference
            headlights.push(leftHeadlight, rightHeadlight);
            
            // Add visible headlight objects (optional)
            const headlightGeometry = new THREE.SphereGeometry(0.2, 16, 16); // Smaller spheres (0.3 â†’ 0.2)
            const headlightMaterial = new THREE.MeshBasicMaterial({ 
                color: headlightColor, 
                emissive: headlightColor,
                emissiveIntensity: 2 // Brighter glow
            });
            
            const leftHeadlightMesh = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlightMesh.position.copy(leftHeadlight.position);
            currentCar.add(leftHeadlightMesh);
            
            const rightHeadlightMesh = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlightMesh.position.copy(rightHeadlight.position);
            currentCar.add(rightHeadlightMesh);
        }

        // Function to update vehicle stats display
        function updateVehicleStats(vehicle) {
            // Update stat bars
            document.getElementById('speed-bar').style.width = (vehicle.speed * 10) + '%';
            document.getElementById('handling-bar').style.width = (vehicle.handling * 10) + '%';
            document.getElementById('acceleration-bar').style.width = (vehicle.acceleration * 10) + '%';
            document.getElementById('shield-bar').style.width = (vehicle.shield * 10) + '%';
            
            // Update description
            document.getElementById('description').textContent = vehicle.description;
        }

        // Listen for vehicle selection changes
        document.getElementById('vehicle-select').addEventListener('change', function(e) {
            const selectedId = e.target.value;
            const selectedVehicle = vehiclesData.find(vehicle => vehicle.id === selectedId);
            if (selectedVehicle) {
                loadCar(selectedVehicle.file);
            }
        });

        // Keyboard Controls
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            w: false,
            a: false,
            s: false,
            d: false
        };

        window.addEventListener('keydown', (event) => {
            if (event.key in keys) {
                keys[event.key] = true;
            }
            
            // Toggle headlights with spacebar
            if (event.code === 'Space') {
                toggleHeadlights();
            }
            
            // Sound horn with 'H' key
            if (event.code === 'KeyH') {
                playHorn();
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key in keys) {
                keys[event.key] = false;
            }
        });

        // Movement Parameters
        let carSpeed = 10; // Units per second 
        let turnSpeed = Math.PI; // Radians per second
        const clock = new THREE.Clock();
        
        // Collision parameters
        const carCollisionRadius = 2.0; // Collision radius for cars
        const collisionRecoveryTime = 1000; // Time in ms before control is restored after collision
        const collisionBounceStrength = 0.5; // How strongly cars bounce off each other
        const treeCollisionBounceStrength = 0.7; // Stronger bounce for trees (they're solid)
        
        // Synchronization time tracking
        let lastUpdateTime = 0;
        const updateInterval = 100; // Send updates every 100ms

        // Emit player movement to server
        function emitPlayerMovement() {
            if (!socket || !socket.connected || !currentCar) return;
            
            socket.emit('playerMovement', {
                position: {
                    x: currentCar.position.x,
                    y: currentCar.position.y,
                    z: currentCar.position.z
                },
                rotation: {
                    y: currentCar.rotation.y
                }
            });
        }

        // Check for collisions with trees
        function checkTreeCollisions() {
            if (!currentCar) return;
            
            // Get player car's position
            const playerPos = currentCar.position.clone();
            
            // Check collision with each tree
            for (const tree of trees) {
                const treePos = tree.position;
                
                // Calculate distance between car and tree
                const distance = playerPos.distanceTo(treePos);
                
                // If distance is less than combined radius, we have a collision
                if (distance < (carCollisionRadius + tree.radius)) {
                    // Handle tree collision
                    handleTreeCollision(treePos);
                    
                    // Only process one collision at a time
                    break;
                }
            }
        }
        
        // Handle collision between player car and a tree
        function handleTreeCollision(treePos) {
            if (controlsDisabled) return; // Already handling a collision
            
            // Calculate collision response direction (pushes away from tree)
            const pushDirection = new THREE.Vector3().subVectors(currentCar.position, treePos).normalize();
            
            // Apply "bounce" force to the player's car - stronger than car collisions because trees don't move
            currentCar.position.add(pushDirection.multiplyScalar(treeCollisionBounceStrength));
            
            // Temporarily disable car controls
            disableControls();
            
            // Play collision sound
            playCollisionSound();
            
            // Show visual collision effect
            showCollisionEffect();
            
            // Update server with new position if connected
            if (socket && socket.connected) {
                emitPlayerMovement();
            }
        }

        // Update Function
        function update(delta) {
            if (currentCar && currentVehicleData) {
                // Apply vehicle-specific characteristics
                carSpeed = currentVehicleData.speed;
                turnSpeed = currentVehicleData.handling * 0.3; // Adjust for reasonable turning

                const acceleration = currentVehicleData.acceleration * 0.1; // Acceleration factor
                
                let hasMoved = false;
                
                // Only process controls if not disabled from a collision
                if (!controlsDisabled) {
                    // Forward movement with either W or ArrowUp
                    if (keys.ArrowUp || keys.w) {
                        currentCar.translateZ(carSpeed * acceleration * delta); // Move forward with acceleration
                        hasMoved = true;
                    }
                    // Backward movement with either S or ArrowDown
                    if (keys.ArrowDown || keys.s) {
                        currentCar.translateZ(-carSpeed * 0.7 * delta); // Move backward (usually slower than forward)
                        hasMoved = true;
                    }
                    // Left turn with either A or ArrowLeft
                    if (keys.ArrowLeft || keys.a) {
                        currentCar.rotation.y += turnSpeed * delta; // Turn left
                        hasMoved = true;
                    }
                    // Right turn with either D or ArrowRight
                    if (keys.ArrowRight || keys.d) {
                        currentCar.rotation.y -= turnSpeed * delta; // Turn right
                        hasMoved = true;
                    }
                }

                // Send movement updates at a controlled rate
                if (hasMoved && socket && socket.connected) {
                    const currentTime = Date.now();
                    if (currentTime - lastUpdateTime > updateInterval) {
                        emitPlayerMovement();
                        lastUpdateTime = currentTime;
                    }
                }

                // Update camera to follow the car
                const cameraOffset = new THREE.Vector3(0, 15, -20); // Position camera above and behind car
                const cameraPosition = new THREE.Vector3().copy(currentCar.position).add(cameraOffset);
                camera.position.lerp(cameraPosition, 0.1); // Smooth camera movement
                camera.lookAt(currentCar.position.x, 0, currentCar.position.z); // Look at car
                
                // Check for collisions with other players
                checkCollisions();
                
                // Check for collisions with trees
                checkTreeCollisions();
            }
            
            // Update other players (interpolate movement)
            for (const id in otherPlayers) {
                const player = otherPlayers[id];
                
                if (player.targetPosition) {
                    // Interpolate position for smooth movement
                    player.position.lerp(player.targetPosition, 0.1);
                    
                    // Interpolate rotation
                    if (player.targetRotation) {
                        // Find shortest path for rotation
                        let targetY = player.targetRotation.y;
                        let currentY = player.rotation.y;
                        
                        // Calculate the difference
                        let diff = targetY - currentY;
                        
                        // Normalize to [-PI, PI]
                        if (diff > Math.PI) diff -= 2 * Math.PI;
                        if (diff < -Math.PI) diff += 2 * Math.PI;
                        
                        // Apply a portion of the rotation
                        player.rotation.y += diff * 0.1;
                    }
                    
                    // Update name label position
                    updateNameLabel(id);
                }
            }
        }

        // Check for collisions between player's car and other cars
        function checkCollisions() {
            if (!currentCar) return;
            
            // Get player car's position
            const playerPos = currentCar.position.clone();
            
            // Check collision with each other player
            for (const id in otherPlayers) {
                const otherPlayer = otherPlayers[id];
                const otherPos = otherPlayer.position.clone();
                
                // Calculate distance between cars
                const distance = playerPos.distanceTo(otherPos);
                
                // If distance is less than the combined collision radius, we have a collision
                if (distance < carCollisionRadius * 2) {
                    // Handle the collision
                    handleCollision(otherPlayer, otherPos);
                    
                    // Notify server about collision
                    if (socket && socket.connected) {
                        socket.emit('carCollision', { 
                            collidedWithId: id,
                            position: {
                                x: currentCar.position.x,
                                y: currentCar.position.y,
                                z: currentCar.position.z
                            }
                        });
                    }
                    
                    // Only handle one collision at a time
                    break;
                }
            }
        }

        // Handle collision between player car and another car
        function handleCollision(otherCar, otherPos) {
            if (controlsDisabled) return; // Already handling a collision
            
            // Calculate collision response direction (pushes away from other car)
            const pushDirection = new THREE.Vector3().subVectors(currentCar.position, otherPos).normalize();
            
            // Apply "bounce" force to the player's car
            currentCar.position.add(pushDirection.multiplyScalar(collisionBounceStrength));
            
            // Temporarily disable car controls
            disableControls();
            
            // Play collision sound
            playCollisionSound();
            
            // Don't show visual effect for initiator (only for victim)
            // The victim will see the effect when they receive playerCollidedWithYou event
        }

        // Disable controls temporarily after collision
        function disableControls() {
            controlsDisabled = true;
            
            // Clear any existing timeout
            if (controlsDisabledTimeout) {
                clearTimeout(controlsDisabledTimeout);
            }
            
            // Re-enable controls after recovery time
            controlsDisabledTimeout = setTimeout(() => {
                controlsDisabled = false;
            }, collisionRecoveryTime);
        }

        // Show visual collision effect
        function showCollisionEffect() {
            const collisionEffect = document.getElementById('collision-effect');
            
            // Reset animation
            collisionEffect.style.animation = 'none';
            collisionEffect.offsetHeight; // Trigger reflow
            
            // Show and animate
            collisionEffect.style.display = 'block';
            collisionEffect.style.animation = 'flash 0.5s';
            
            // Hide after animation completes
            setTimeout(() => {
                collisionEffect.style.display = 'none';
            }, 500);
        }

        // Play collision sound
        function playCollisionSound() {
            if (audioContext) {
                // Create an oscillator for a quick crash sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            }
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            update(delta);
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        // Function to toggle headlights
        function toggleHeadlights() {
            // Toggle state
            headlightsOn = !headlightsOn;
            
            // Toggle player's headlights
            if (headlights.length > 0) {
                headlights.forEach(light => {
                    light.visible = headlightsOn;
                });
            }
            
            // Notify server about headlight state change
            if (socket && socket.connected) {
                socket.emit('headlightsToggle', { headlightsOn });
            }
        }

        // Play collision sound for distant collisions (between other players)
        function playDistantCollisionSound() {
            if (audioContext) {
                // Create an oscillator for a quick crash sound (quieter than direct collisions)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.15);
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Lower volume for distant collisions
                gainNode.gain.exponentialRampToValueAtTime(0.005, audioContext.currentTime + 0.15);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
            }
        }

        // Initialize Audio and Start Animation
        initAudio();
        animate();
    </script>
</body>
</html>